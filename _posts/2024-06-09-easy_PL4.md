---
title: Easy Foundations for Programming Languages IV â€” PCF Analysis
date: 2024-06-08 21:00:00 +500
math: true
categories: [Theory, Programming Language]
tags: [note, lang-en, PL]
---

In the last article, we have seen all of the structure of PCF, now we will take a step back and discuss the meaning, or **semantics**, in a general way. We want our discussion can be applied to a variety of programming languages.

The three forms of semantics we will consider are **axiomatic semantics**, given by a proof system, **operational semantics** arising from a set of reduction rules and **denotational semantics**. Each form of semantics has advantages and disadvantages for understanding properties of programs. In addition, there are standard connection between the three forms of semantics that should hold for any programming language. We will discuss them in this article.

## PCF Programs

In any programming language, not all well-formed syntactic entities can be executed or evaluated. Therefore, we distinguish **programs** from other syntactic forms that may be used only as parts of programs. A program has two characteristics: (1) a program should not refer to any undeclared or unbound variables; (2) and a program should have the appropriate type or form to yield a printable value or observable effect.

PCF has two syntactic categories: types and terms (expressions that have types). In PCF, we consider closed boolean and numeric expressions programs, because we can expect interpreter to directly print their values. If we give an open natural number term such as $x+5$ to an interpreter, there is no correct value since the value to $x$ is not given.

>Recall: "closed" means that the expression does not contain free variables.
{: .prompt-tip}

In addition, we cannot expect the value of a function expression to be printed with the same degree of accuracy as a natural number or boolean. No interpreter can print function expressions in a way that would tell us exactly which mathematical function is defined by the function expression typed in. This is because, which we will explain in future articles, *equality for partial recursive function is undecidable and every partial recursive function is definable in PCF*. For this reason, we say that natural number and boolean values are **observable**, but $nat \rightarrow nat$ values are not.

Formally put, in PCF, we say $\tau$ is an **observable type** if $\tau$ is either $nat$ or $bool$. A **PCF program** is a well-formed, closed term of observable type.

>One potentailly confusing aspect of this definition is that it does not consider input or output; it might be more accurate to call these "programs that require no additional input and produce one output." This allows us to more easily compare axiomatic, operational, and denotational semantics.
{: .prompt-tip}

Another general term we use in comparing semantics is **result**. Intuitively, a result is an observable effect of evaluating or executing a program. For PCF, we make this precise by saying that a *result* is a closed normal form of observable type. In other words, the PCF results are the numerals $0,1,2,...$ and boolean constants $true$ and $false$.

>Recall: "normal form" means that the expression cannot be simplified further.
{: .prompt-tip}

With this terminology, now we can give a general definition of semantics: a **semantics** of programs is a relation between programs and results.

## Axiomatic Semantics

In general, an axiomatic semantics consists of a proof system for deducing properties of programs and their parts. These properties may be equations, assertions about the output of programs, or other properties.

There are three general properties of axiomatic semantics that hold for PCF. The first is that the axiomatic semantics defines program behavior in some way. The other two are relations betwwen the axiomatic and operational or denotational semantics.

- The axiomatic semantics determine the result (or output or observable effect, in general) of any program that has one.

- When two expressions are equivalent, according to the axiomatic semantics, we may safely substitute one for the other in any program without changing the operational semantics of that program. This could be called "soundness of the axiomatic semantics with respect to the operational semantics."

- The axiomatic semantics are sound with respect to the denotational semantics. Specifically, if we can prove any pair of PCF terms equal, then these terms must have the same denotation, regardless of which values we give to their free variables.

The axiomatic semantics of PCF is given by the proof system shown in this [table]({{ site.url }}/assets/img/2024-06-09/ProofSys_for_PCF.png). 

In the table, **congruence** means that provable equality is an equivalence relation (reflexive, symmetric and transitive), and that equality is preserved if we replace any subexpression by an equivalent one.

>All the congruence rules except two about "Functions" are in fact redundant!  
For example, suppose we can prove $M=N$ and $P=Q$, for four natural number expressions $M,N,P,Q$, then we can derive $M+N=P+Q$ as follows.  
By the reflexivity axiom, we have the equation  
$$ \lambda x:nat.\lambda y:nat.x+y = \lambda x:nat.\lambda y:nat.x+y.$$  
Therefore, by the congruence rule for function application, we can prove  
$$ (\lambda x:nat.\lambda y:nat.x+y)\:M = (\lambda x:nat.\lambda y:nat.x+y)\:N.$$  
Then, by axiom scheme $(\beta)$ and transitivity,  
$$ \lambda y:nat.M+y = \lambda y:nat.N+y.$$  
Repeating the application, $(\beta)$, and transitivity, we may complete the proof of $M+N=P+Q$.
{: .prompt-tip}

It is worth mentioning that although the axiomatic semantics is powerful enough to determine the meaning of programs, this proof system is not as powerful as one might initially expect. For example, we cannot even prove that addition is commutative. Nor can we prove many interesting equivalences between recursive functions.

>A binary operation is **commutative** if changing the order of the operands does not change the result.
{: .prompt-tip}

To adapt these properties, the most natural approach would be to add induction rules. Induction on natural numbers would let us prove commutativity quite easily, and a form of induction called "fixed-point induction" would allow us to prove a great many more equations between recursively-defined functions.
