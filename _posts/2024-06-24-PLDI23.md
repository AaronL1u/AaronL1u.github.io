---
title: PLDI 2023 Personal Note
date: 2024-06-24 10:00:00 +500
math: true
categories: [Conference]
tags: [note, lang-en, PL]
---

PLDI (Conference on Programming Language Design and Implementation) 2023, as the most famous conference in the programming language theory field, was held at Orlando, Florida in June. It accepted 83 papers, and 8 were awarded as distinguished papers.

In this note, let's go through all the distinguished papers to see what have they done in their field.


## Distinguished Papers

### An Automata-Based Framework for Verification and Bug Hunting in Quantum Circuits

**Author:** [Yu-Fang Chen](https://bull.iis.sinica.edu.tw/yfc/doku.php), Kai-Min Chung, Ondřej Lengál, Jyun-Ao Lin, Wei-Lun Tsai, Di-De Yen

[[pdf]]({{ site.url }}/download/PLDI23/framework_for_quantum_circuits.pdf)

The first anthor of this paper, Yu-Fang Chen, is a research fellow at Acadenua Sinica, Taiwan. He has 17 years research exprience on automata. This time he novely applied automata on solving the quantum circuits problem and won his first distinguished paper award, also this is his first paper related to quantum circuits. 

His team proposed a new paradigm for analyzing and finding bygs in quantum circuits. Their framework is based on **binary tree automata**, for which you may find a systematical introduction in an ealier book [[Comon et al. 2008](https://inria.hal.science/hal-03367725/document)]. The approach uses tree automata (TA) to represent sets of quantum states and employs TA transformation algorithms to execute quantum gates over the automata. By doing so, they bridge the gap between quantum and classical verification and establishe a connection between automata theory and the quantum world.

For curious readers who want to know how automata is used to find bugs in detail, we provide a step-by-step explaination [here](#how-bugs-are-found-using-automata).


### Covering All the Bases: Type-Based Verification of Test Input Generators

**Author:** [Zhe Zhou](https://zhezhouzz.github.io/), Ashish Mishra, Benjamin Delaware, Suresh Jagannathan

[[pdf]]({{ site.url }}/download/PLDI23/cover_all_bases.pdf)

This work comes from a Ph.D. student at Purdue University under the guidence of [Suresh Jagannathan](https://www.cs.purdue.edu/homes/suresh/). This is his second published paper. Their group has an active line of investigating the application of expressive type systems to facilitate the verification of non-trivial properties of functional programs.

In this paper, they discuss test input generators. One limitation of existing generators is that it is hard to validate a particular generator's output satisfies the **coverage** requirement. (Coverage is a metric in software testing that measures the percentage of code that is actually examined under specific test inputs.) So, their idea is to embed the notion of coverage as an integral part of a test input generator’s type specification. By doing so, a generator’s type now specifies the set of behaviors the generator is guaranteed to exhibit; a well-typed generator is thus guaranteed to produce every possible value satisfying a desired structural property.

More specifically, this paper introduces the notion of **coverage types**, and formalizes the semantics of coverage typess in OCaml. Moreover, it develops a bi-directional type-checking algorithm for coverage types and implements as a tool operating over OCaml programs. In principle, this paper adapts underapproximate reasoning found in recent work on incorrectness logic (IL) [[O’Hearn 2019](https://dl.acm.org/doi/10.1145/3371078); [Raad et al. 2020]({{ site.url }}/download/PLDI23/incorrectness_separation_logic.pdf)]. Check [here](#what-is-underapproximate-reasoning-of-a-program) to see what underapproximate reasoning means.


### CryptOpt: Verified Compilation with Randomized Program Search for Cryptographic Primitives

**Author:**  [Joel Kuepper](https://researchers.adelaide.edu.au/profile/joel.kuepper), Andres Erbsen, Jason Gross, Owen Conoly, Chuyue Sun, Samuel Tian, David Wu, Adam Chlipala, Chitchanok Chuengsatiansup, Daniel Genkin, Markus Wagner , Yuval Yarom

Surprisingly, the first author Joel Kuepper is the youngest one among 12 authors. And this is the debut work of him. No evidence shows who is the advisor of Joel Kuepper.

This paper present the first compiler that specializes high-level cryptographic functional programs into assembly code, named CryptOpt. They claim that the generated code runs significantly faster than what GCC or Clang produce. On the formal-verification side, they connect to the Fiat Cryptography framework (which translates functional programs into C-like IR code) and extend it with a new formally verified program-equivalence checker, incorporating a modest subset of known features of SMT solvers and symbolic-execution engines.

This is a classical PL paper about compiler design and implementation. This kind of work requires large amount of effort and undoubtedly deserves a distinguished award. It is hard to believe that Joel Kuepper, as a freshman in the research field, could lead such a complicated task and put everything nicely to the ground. Awesome!


[[pdf]]({{ site.url }}/download/PLDI23/CryptOpt.pdf)

### Extensible Metatheory Mechanization via Family Polymorphism

**Author:** Ende Jin, Nada Amin, Yizhou Zhang

[[pdf]]({{ site.url }}/download/PLDI23/extensible_matatheory.pdf)


### Mosaic: An Interoperable Compiler for Tensor Algebra

**Author:** Manya Bansal, Olivia Hsu, Kunle Olukotun, Fredrik Kjolstad

[[pdf]]({{ site.url }}/download/PLDI23/mosaic.pdf)


### Mostly Automated Proof Repair for Verified Libraries

**Author:** Kiran Gopinathan, Mayank Keoliya, Ilya Sergey

[[pdf]]({{ site.url }}/download/PLDI23/auto_proof_repair.pdf)


### Synthesizing MILP Constraints for Efficient and Robust Optimization

**Author:** Jingbo Wang, Aarti Gupta, Chao Wang

[[pdf]]({{ site.url }}/download/PLDI23/MILP_constraints.pdf)


### Trace-Guided Inductive Synthesis of Recursive Functional Programs

**Author:** Yongwei Yuan, Arjun Radhakrishna, Roopsha Samanta

[[pdf]]({{ site.url }}/download/PLDI23/synthesis_of_recursive_functional_program.pdf)


## Appendix

### How bugs are found using automata?

1. Problem Specification: The problem is given by a triple $$\{P\} \: C \: \{Q\}$$ , where $P$ represents a set of quantum states on the input of a circuit $C$, and $Q$ represents a set of quantum states on the output of the circuit. The question is whether the set of quantum states on the output is equal to (or included in) the set $Q$. 
​

2. Compact Representation: Tree automata are used to compactly represent sets of quantum states. Tree automata are mathematical structures that can recognize or generate tree languages. In this case, they are used to represent the sets of quantum states. 
​

3. Semantics of Quantum Gates: Transformers are developed to implement the semantics of quantum gates over the representation provided by tree automata. These transformers define how the quantum gates affect the quantum states.

4. Algebraic Representation: The technique computes with an algebraic representation of quantum states, avoiding the inaccuracy of working with floating-point numbers. This algebraic representation allows for precise calculations and comparisons.

5. Verification Process: The proposed approach verifies the correctness of the quantum circuit by comparing the expected output set $Q$ with the actual output set obtained from the circuit $C$. The tree automata representation and the transformers are used to perform this verification.

6. Bug Detection: If the actual output set does not match the expected output set, it indicates the presence of a bug in the quantum circuit. The technique can identify discrepancies between the expected and actual output sets, allowing for the detection of bugs.

7. Scalability and Performance: The performance of the approach is evaluated against various benchmarks from the literature. The evaluation shows that the approach is scalable and can handle large-scale circuits with a significant number of qubits and gates. It also outperforms other existing tools in terms of bug detection.


### What is underapproximate reasoning of a program?

Underapproximate reasoning of a program refers to a method of reasoning about the behavior and properties of a program by considering a conservative approximation of its possible outcomes. It involves making conservative assumptions or approximations about the program's behavior in order to simplify the analysis and make it more tractable. Underapproximate reasoning focuses on capturing a subset of possible program behaviors that are guaranteed to hold true, while potentially missing some specific or complex behaviors. 

This approach is often used in program analysis and verification to establish safety properties, prove correctness, detect bugs, or guide program optimizations. It provides a trade-off between precision and efficiency, allowing for scalable and sound analysis results while sacrificing some level of completeness.