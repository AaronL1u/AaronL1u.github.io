---
title: Easy Foundations for Programming Languages VIII — Proof Systems
date: 2024-06-27 01:39:00 +500
math: true
categories: [Theory, Programming Language]
tags: [note, lang-en, PL]
---


The equational proof system of typed lambda calculus may be used to derive equations that hold in all models, and to derive equations that follow from equational hypothesis.

## Equations

<!-- Unlike algebra, the valid equations between typed lambda terms are nontrivial. In this section, we will devote some attention to the relationship between typed lambda calculus and algebra. In addition, to illustrate the expressiveness of typed lambda calculus, we also describe the lambda theory corresponding to a fixed set of recursive types and a theory for the higher-order logic. -->

> The equivalence we discuss in this article is the axiomatic equivalence. Recall that "axiomatic semantics consists of a proof system for deducing properties of programs and their parts" in [*Easy Foundations for Programming Languages IV — PCF Semantics*]({{site.url}}/posts/easy_PL4/).
{: .prompt-tip}

A typed equation has the form

$$
\begin{split}\\
\Gamma \:\triangleright\: M = N:\tau
\end{split}
$$

where we assume that $M$ and $N$ have type $\tau$ in context $\Gamma$.

Intuitively, the equation $$ \{ x_1:\sigma_1 ,..., x_k:\sigma_k \} \:\triangleright\: M = N:\tau$$ means that for all type-correct values of the variables $x_1:\sigma_1 ,..., x_k:\sigma_k$, expressions $M$ and $N$ denote the same element of type $\tau$. Another way of writing this equation might be

$$\forall x_1:\sigma_1 ...\forall x_k:\sigma_k \: .\: M = N:\tau.$$

> Because the variables listed in the type assignment are universally quantified, an equation may hold vacuously if some type is empty.  
For example, if $\sigma$ is empty, then the equation $$\forall x:\sigma . \forall y:\rho . M = N:\tau$$ is true simply because there is no possible value for $x$.
{: .prompt-tip}

Since we include type assignments in equations, we have an equational version of the typing rule that adds variables to type assignments,

$$\frac{\Gamma \:\triangleright\: M = N:\sigma}{\Gamma , x:\tau \:\triangleright\: M = N:\sigma} \tag*{($add \: var$)}$$

The next group of axioms and inference rules make provable equality an *equivalence relation*. 

$$\Gamma \:\triangleright\: M = M:\sigma \tag*{($ref$)}$$

$$\frac{\Gamma \:\triangleright\: M = N:\sigma}{\Gamma \:\triangleright\: N = M:\sigma} \tag*{($sym$)}$$

$$\frac{\Gamma \:\triangleright\: M = N:\sigma ,\: \Gamma \:\triangleright\: N = P:\sigma}{\Gamma \:\triangleright\: M = P:\sigma} \tag*{($trans$)}$$



> An **equivalence relation** is a binary relation that is reflexive, symmetric and transitive. More to see this [wiki page](https://en.wikipedia.org/wiki/Equivalence_relation).
{: .prompt-tip}

The two term-formation operations of $\lambda^\to$ are abstraction and application, both of which preserve equality. The rule

$$\frac{\Gamma,x:\sigma \:\triangleright\: M = N:\tau}{\Gamma \:\triangleright\: \lambda x :\sigma.M = \lambda x :\sigma.N:\sigma \to \tau} \tag*{($\xi$)}$$

says that if $M$ and $N$ are equal for all values of $x$, then the two functions $\lambda x :\sigma.M$ and $\lambda x :\sigma.N$ are equal.

For application, we have the rule

$$\frac{\Gamma\:\triangleright\: M_1 = M_2:\sigma \to \tau,\: \Gamma \:\triangleright\: N_1 = N_2:\sigma}{\Gamma \:\triangleright\:M_1\: N_1 = M_2\:N_2:\tau} \tag*{($\nu$)}$$

saying that equals applied to equals yield equals.

> It is interesting to note that these two rules have the same form as the introduction and elimination rules for $\to$.
{: .prompt-tip}

For $\lambda^\to$, three axioms remain. The first describe renaming of bound variables, while the other two specify that the introduction and elimination rules are "inverses" of each other. These axioms are already illustrated in previous articles, so we just list them below and will not discuss them in detail here.

$$\Gamma \:\triangleright\: \lambda x:\sigma.M = \lambda y:\sigma.[y/x]M : \sigma \to \tau \text{, provided } y \notin FV(M)\tag*{($\alpha$)}$$

$$\Gamma \:\triangleright\: (\lambda x:\sigma.M)\:N = [N/x]M : \tau \tag*{($\beta$)}$$

$$\Gamma \:\triangleright\: \lambda x:\sigma.(M\:x) = M : \sigma \to \tau \text{, provided } x \notin FV(M)\tag*{($\eta$)}$$

> $FV(M)$ represents the set of free variables in $M$, i.e., the variables appearing in $M$ that are not bound by $\lambda$. 
{: .prompt-tip}

The following lemma can be easily proved by induction on equational proofs.

**(Lemma.)** If $$\vdash \Gamma\:\triangleright\: M = N:\sigma$$ and $\Gamma \cap \Gamma'$ contains all free variables of $M$ and $N$, then $$\vdash \Gamma'\:\triangleright\: M = N:\sigma$$.

> $\vdash M = N:\sigma$ means that the equation $M=N$ could be proved without any assumption. In other words, using axioms and inference rules is sufficient to prove $M = N$.  
If you have read the *Correspondence between Formulas and Types* section in the last article, you may better understand the meaning of $\vdash$. We put further explanation of this symbol at the [end](#what-is-the-exact-meaning-of-vdash-) of this article.
{: .prompt-tip}


## Theories

A **typed lambda theory** (or $\boldsymbol{\lambda^\to}$ **theory**) over signature $\Sigma$ is a set of well-typed equations between $\Sigma$-terms that includes all instances of the axioms and is *closed* under the inference rule. We use the word "close" here to mean that any equation generated by inference rules will not go beyond this set.

If $\mathcal{E}$ is any set of well-typed equations, we write $$\mathcal{E} \vdash \Gamma\:\triangleright\: M= N:\sigma$$ to mean that the equation $$\Gamma\:\triangleright\: M= N:\sigma$$ is provable from the axioms and equations of $\mathcal{E}$.

The **theory of** $\boldsymbol{\mathcal{E}}$, written $Th(\mathcal{E})$, is the set of equations provable from the axioms and equations of $\mathcal{E}$.

<!-- Given any algebraic signature $\Sigma$, there is a corresponding $\lambda^\to$ signature $\Sigma_\to$ such that every algebraic term over $\Sigma$ is a $\lambda^\to$ term over $\Sigma_\to$. This allows us to regard any algebraic equations as $\lambda^\to$ equations.

> Recall that we defined $\Sigma_\to$ in [*Easy Foundations for Programming Languages VII — Simply-Typed Lambda Calculus*]({{site.url}}/posts/easy_PL7/#syntax-of-lambdarightarrow-terms).
{: .prompt-tip} -->


## What is the Exact Meaning of $\vdash$ ?

The symbol $\vdash$ is widely used in [proof calculus](https://en.wikipedia.org/wiki/Natural_deduction), or called **proof system**. To date, there are three most widely known proof calculus:

- The class of **Hilbert systems**, of which the most famous example is the 1928 [Hilbert–Ackermann system](https://en.wikipedia.org/wiki/Hilbert_system) of first-order logic. We introduce this one in [*Easy Foundations for Programming Languages II — Notation and mathematical Conventions*]({{site.url}}/posts/easy_PL2/#induction-on-proofs);

- Gerhard Gentzen's calculus of [natural deduction](https://en.wikipedia.org/wiki/Natural_deduction), which is the first formalism of structural proof theory, and which is the cornerstone of the formulae-as-types correspondence relating logic to functional programming we discussed in [*Easy Foundations for Programming Languages VII — Simply-Typed Lambda Calculus*]({{site.url}}/posts/easy_PL7/#correspondence-between-formulas-and-types);

- Gentzen's [sequent calculus](https://en.wikipedia.org/wiki/Sequent_calculus), which is the most studied formalism of structural proof theory.

> There is another very famous but no longer widely used proof calculus —  Aristotle's **syllogistic calculus**, presented in his 350 BC book *Prior Analytics*. This book represents the first time in history when Logic is scientifically investigated.  
The Aristotelian syllogism dominated Western philosophical thought for many centuries. Syllogistic arguments are usually represented in a simple three-line form:  
*All men are mortal.*  
*Socrates is a man.*  
*Therefore, Socrates is mortal.*  
Check this [wiki page](https://en.wikipedia.org/wiki/Syllogism) to see more about Syllogism.
{: .prompt-tip }

In these proof calculus, Suppose $\Gamma$ is a set of formulas, considered as **hypotheses** or **assumptions**. For example, $\Gamma$ could be a set of axioms for group theory or set theory. 

The notation $\Gamma \vdash \phi$ means that there is a deduction that ends with $\phi$ using as axioms only logical axioms and elements of $\Gamma$. Thus, informally, $\Gamma \vdash \phi$ means that 
$\phi$ is provable assuming all the formulas in $\Gamma$. We write $\vdash \phi$ to mean that $\phi$ is provable without assumption.

Suppose we have three formulas $\psi$, $\omega$, and $\phi$. To express "$\phi$ is provable when $\psi$ and $\omega$ hold," we have the following four kinds of style to write this inference rule. 

$$\psi, \omega \vdash \phi$$

$$\frac{\:}{\psi, \omega \vdash \phi}$$

$$\frac{\psi, \omega}{\phi}$$

$$\frac{\vdash \psi, \omega}{\vdash \phi}$$

These four rules share the same meaning. In essence, you may use whichever you like.

In many literature on type systems, natural deduction or sequent calculus are used. In these sources, it is common to use $\Gamma \vdash M:\sigma$ to indicate that the typing assertion $M:\sigma$ is provable from the set $\Gamma$ of typing assumptions. In our series, however, we use the symbol $\triangleright$ in type assertions instead of $\vdash$, because we want to differentiate the type system from the equational proof system introduced in this article.