---
title: Easy Foundations for Programming Languages I â€” Introduction
date: 2024-05-19 16:19:00 +500
math: true
categories: [Theory, Programming Language]
tags: [note, lang-en, PL]
---


## Model Programming Languages

The formulation of "model" programming languages is the beginning for a mathematical analysis. The word "model" here means that the language we want to analyze is a simplified language, which discards all irrelevant details of the orignial large language. We can call such a simplified version as a **sublanguage** of the original one. This process is quite useful in both analyzing existing languages and designing a new language. 

Of course, some good properties we find on the sublanguage may not hold on the orignal language. Having a good taste and careful judgement is important for the "modeling". In this series, we will go through fundamental programming language concepts using the framework of **typed lamda calculus**, which allows us to see beyond the surface syntax and to understand the meanings of program phrases (expressions, commands, declarations, etc.) at an **appropriate** level of detail. 

> This "appropriate" description is intriguing, since there is no single "appropriate level of detail" that is appropriate for all forms of programming and program analysis. So we concentrate on general techniques that may be applied in a variety of ways.
{: .prompt-tip }


## Lambda Notation

Lambda calculus was introduced by mathematician Alonzo Church in the 1930s as part of an investigation into the [foundations of mathematics](https://en.wikipedia.org/wiki/Foundations_of_mathematics), a study of the philosophical and logical. The lambda calculus provides simple semantics for computation which are useful for formally studying properties of computation. To date, lambda calculus has proven useful in describing, analyzing, and implementing programming languages.

Lambda notation has two primary features: Lambda **abstraction** and **application**. In the next two subsections, we will explain their details.

### Lambda Abstraction

Lambda abstraction is what we use to write function expressions. Expressions written in lambda notation are called **lambda expressions** or **lambda terms**. A simple example of the lambda expression is below.

$$\lambda x: nat. x$$

This is an identity function on natural numbers. Simply speaking,it represents a mathatical function $$f(x)=x$$. The notation "$$x:nat$$" specifies the domain of this function is $$\boldsymbol{nat}$$, the type of natural numbers. In other words, this function only accepts a positive integer as the input, and return this value directly, so the fucntion range is also $$nat$$.

> Writing the lambda expression in the $$f(x)=x$$ notation is helpful for us to understand, but there are two details to notice:
1. This notation doesn't provide any contraint on the type of input;
2. The notation forces us to make up a name (here, $$f$$) for every function we write, while lamdba notation gives us a succient way of defining function directly without a name. ($$\lambda$$ is just a symbol)
{: .prompt-tip }

More genarally, we can write a lambda expression in the following format:

$$\lambda x: \sigma.\: M$$

, where $$M$$ is some expression acting as the function body. This expression defines the function mapping any $$x$$ in $$\sigma$$ type to the value given by $$M$$.


### Lambda Application

Application allows us to make use of the functions we defined during the abstraction. In lambda notation, we write function application just by putting a function expression next to one or more arguments.

For example, we apply the natural-number identity function to the number 3 by writing the following.

$$(\lambda x: nat.\: x) \: 3$$

This function will return 3 as the output, which gives us such an equation.

$$(\lambda x: nat.\: x) \: 3 = 3$$

There are two conventions in writing lambda notations:

1. Application associates to the left, so that $$MNP$$ should be read as $$(MN)P$$. In words, we can read $$MNP$$ as the expression, "apply the function $$M$$ to argument $$N$$, and then apply the resulting function to argument $$P$$." **(In short, apply from left to right.)**

2. The scope of each lambda is interpreted as being as large as possible. For example, we read $$\lambda x: \sigma. MN$$ as $$\lambda x: \sigma. (MN)$$, rather than $$(\lambda x: \sigma. M)N$$. **(In short, extend function body as far as you can.)**

The two conventions work well together. For example, a multi-argument function application may be written

$$ (\lambda x:\sigma .\: \lambda y:\tau .\: \lambda z:\rho . M) \: N \: P \: Q .$$

According to the two conventions, this expression is fully parenthesized as

$$ (((\lambda x:\sigma . (\lambda y:\tau . (\lambda z:\rho . M))) \: N) \: P) \: Q .$$

> These conventions make lambda expressions easier to write and read, but they are hard to understand at first. You need some practice to get used to.
{: .prompt-tip }

### Example

Following is a snippet of C program, which defines a function to add two integers together, and then invokes this function using parameters 3 and 5.

```c
int add(int a, int b) {
    return a + b;
}
add(3, 5);
```

Using the lambda notation, we can use following expression to model the behavior of this program.

$$ (\lambda x:int .\: \lambda y:int .\:x+y) \: 3 \: 5  $$
