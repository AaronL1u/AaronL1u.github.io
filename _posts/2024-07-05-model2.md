---
title: Denotational Semantics of Typed Lambda Calculus II — Domain-Theoretic Models
date: 2024-07-05 20:57:00 +500
math: true
categories: [Theory, Programming Language]
tags: [note, lang-en, PL]
---

## Recursive Definitions and Fixed Point Operators

To motivate the central properties of domains, we start from an intuitive discussion of recursive definitions. Recall from [*Easy Foundations for Programming Languages III — The Language PCF & Its Syntax*]({{ site.url }}/posts/easy_PL3/#recursion-and-fixed-point-operators) that if we wish to add a recursive definition form

$$\text{letrec } f:\sigma = M \text{ in } N$$

to typed lambda calculus, it suffices to add a fixed-point operator $fix_\sigma$ that returns a fixed point of any function from $\sigma$ to $\sigma$.

Therefore, we study a class of models for $\lambda^{\times,\to}$, and extensions, in which functions of the appropriate type have fixed points. A specific example will be a model (denotational semantics) of PCF.

We will use properties of ($fix$) reduction to motivate the semantic interpretation of $fix$. To emphasize a few points about ($fix$) reduction, we will review the factorial example discussed in that article. In this example, we assume reduction rules for conditional, equality test, substraction and multiplication.

Using $fix_{nat \to nat}$, the factorial function may be written $$fact \:\stackrel{\text{def}}{=} \: fix_{nat \to nat} \: F$$, where $F$ is the expression

$$F \:\stackrel{\text{def}}{=} \: \lambda f:nat \to nat.\: \lambda y:nat.\: \text{if } Eq? \: y \: 0 \text{ then } 1 \text{ else } y*f(y-1).$$

Since the type is clear from context, we will drop the subscript from $fix$. To compute $$fact \: n$$, we expand the definition, and use reduction to obtain the following.

$$
\begin{split}
fact \: n &= (\lambda f : nat \to nat .\: f(fix \: f)) \: F \: n\\
&= F \: (fix \: F) \: n \\
&= (\lambda f:nat \to nat.\: \lambda y:nat.\: \text{if } Eq? \: y \: 0 \text{ then } 1 \text{ else } y*f(y-1))\: (fix \: F) \: n \\
&= \text{if } Eq? \: n \: 0 \text{ then } 1 \text{ else } n*(fix \: F)(n-1)
\end{split}
$$

When $n=0$, we can use the reduction axiom for conditional to simplify $fact$ $0$ to $1$. For $n > 0$, we can simplify the test to obtain $$n*(fix \: F)(n-1)$$, and continue as above. For any numeral $n$, we will eventually reduce $fact$ $n$ to the numeral for $n!$.

An alternative approach to understanding $fact$ is to consider the finite expansions of $fix$ $F$. 

To make this as intuitive as possible, let us temporarily think of $nat \to nat$ as a collection of partial functions on the natural numbers, represented by sets of ordered pairs. Using a constant $diverge$ for the "nowhere defined" function (the empty set of ordered pairs). we let the "zero-th expansion" $$fix^{[0]} \: F = diverge$$ and define

$$fix^{[n+1]} \: F = F \:(fix^{[n]} \: F )$$

In computational terms, $fix^{[n]}$ $F$ describes the recursive function computed using at most $n$ evaluations of the body of $F$. Or, put another way, $fix^{[n]}$ $F$ is the best we could do with a machine having such limited memory that allocating space for more than $n$ function calls would overflow the run-time stack.

For example, we can see that $$(fix^{[2]} \: F)\:0=1$$ and $$(fix^{[2]} \: F)\:1=1$$, but $$(fix^{[2]} \: F)\:n$$ is undefined for $n \geq 2$.